/*
Categoría: Comportamental
Propósito: Definir una familia de algoritmos, encapsularlos y hacerlos 
intercambiables. Permite que el algoritmo varie independientemente del cliente.
Cómo funciona:

Se define una interfaz común para todas las estrategias.

El contexto utiliza una estrategia concreta.
Ejemplo:
Diferentes algoritmos de ordenamiento que se pueden usar según la necesidad
*/

//Interfaz
interfaz EstrategiaPago {
    metodo pagar(monto: Decimal)
}

//Estrategias Concretas
clase PagoConTarjeta implementa EstrategiaPago {
    metodo pagar(monto) {
        imprimir "Pagando " + monto + " con tarjeta de crédito."
    }
}

clase PagoConPaypal implementa EstrategiaPago {
    metodo pagar(monto) {
        imprimir "Pagando " + monto + " con PayPal."
    }
}

clase PagoEnEfectivo implementa EstrategiaPago {
    metodo pagar(monto) {
        imprimir "Pagando " + monto + " en efectivo."
    }
}

//Contexto
clase CarritoCompras {
    propiedad estrategia: EstrategiaPago

    metodo setEstrategia(estrategia: EstrategiaPago) {
        this.estrategia = estrategia
    }

    metodo procesarPago(monto: Decimal) {
        if estrategia ≠ null {
            estrategia.pagar(monto)
        } else {
            imprimir "No se ha definido una estrategia de pago."
        }
    }
}

//Uso del patron
carrito = new CarritoCompras()

carrito.setEstrategia(new PagoConTarjeta())
carrito.procesarPago(50.0)
// Salida: Pagando 50.0 con tarjeta de crédito.

carrito.setEstrategia(new PagoConPaypal())
carrito.procesarPago(30.0)
// Salida: Pagando 30.0 con PayPal.

carrito.setEstrategia(new PagoEnEfectivo())
carrito.procesarPago(20.0)
// Salida: Pagando 20.0 en efectivo.
